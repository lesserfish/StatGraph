#' Semi-Parametric Analysis Of Graph Variability (ANOGVA)
#'
#' \code{sp.anogva} statistically tests whether two or more graphs are
#' generated by the same model and set of parameters.
#'
#' @param G a list of undirected graphs (igraph type) or their adjacency
#' matrices. The adjacency matrix of an unweighted graph contains only 0s and
#' 1s, while the weighted graph may have nonnegative real values that correspond
#' to the weights of the edges.
#'
#' @param model A string that indicates one of the following models: "ER"
#' (Erdos-Renyi random graph model), "GRG" (geometric random graph model), "WS"
#' (Watts-Strogatz random graph model), and "BA" (Barabasi-Albert random graph
#' model).
#'
#' @param maxBoot integer indicating the number of bootstrap resamples (default
#' is 500).
#'
#' @param spectra optional parameter containing the precomputed spectrum of the
#' model. It is a three-dimensional array in which the first dimension
#' corresponds to all parameters that will be explored in the parameter
#' estimation, the second dimension has the same size of the given graph, and
#' the third one corresponds to graphs randomly generated by the model. Thus,
#' the position (i,j,k) contains the j-th eigenvalue of the k-th graph generated
#' with the i-th parameter. The attribute 'rownames' of the array corresponds to
#' the parameters converted to string. If spectra is NULL (default), then
#' model' is used to generate random graphs and their spectra are computed
#' automatically.
#'
#' @param eps (default is 0.01) precision of the grid when 'classic' = TRUE.
#'
#' @param classic logical. If FALSE parameter is estimated using the graph
#' parameter estimator, where this option works better for large graphs with
#' 1000 or more nodes. If TRUE (default) parameter is estimated using grid
#' search.
#'
#' @param bandwidth string showing which criterion is used to choose the
#' bandwidth during the spectral density estimation. Choose between the
#' following criteria: "Silverman" (default), "Sturges", "bcv", "ucv" and "SJ".
#' "bcv" is an abbreviation of biased cross-validation, while "ucv" means
#' unbiased cross-validation. "SJ"  implements the methods of Sheather & Jones
#' (1991) to select the bandwidth using pilot estimation of derivatives.
#'
#' @return A list with class "htest" containing the following components:
#' \item{statistic}{the F statistic of the test.}
#' \item{p.value}{the p-value of the test.}
#' \item{method}{a string indicating the used method.}
#' \item{data.name}{a string with the data's name(s).}
#' \item{estimates}{a vector containing the estimated parameters for each graph.}
#'
#' @keywords semi_parametric_analysis_of_graph_variability
#'
#' @references
#'
#' Andre Fujita, Eduardo Silva Lira, Suzana de Siqueira Santos, Silvia Yumi
#' Bando, Gabriela Eleuterio Soares, Daniel Yasumasa Takahashi. A
#' semi-parametric statistical test to compare complex networks, Journal of
#' Complex Networks, cnz028, https://doi.org/10.1093/comnet/cnz028
#'
#' Sheather, S. J. and Jones, M. C. (1991). A reliable data-based bandwidth
#' selection method for kernel density estimation.
#' _Journal of the Royal Statistical Society series B_, 53, 683-690.
#' http://www.jstor.org/stable/2345597.
#'
#' @examples
#' \dontrun{
#' set.seed(42)
#' model <- "ER"
#' G <- list()
#'
#' # Under H0
#' G[[1]] <- igraph::sample_gnp(50, 0.5)
#' G[[2]] <- igraph::sample_gnp(50, 0.5)
#' G[[3]] <- igraph::sample_gnp(50, 0.5)
#' result1 <- sp.anogva(G, model, maxBoot = 300)
#' result1
#'
#' # Under H1
#' G[[1]] <- igraph::sample_gnp(50, 0.5)
#' G[[2]] <- igraph::sample_gnp(50, 0.55)
#' G[[3]] <- igraph::sample_gnp(50, 0.5)
#' result2 <- sp.anogva(G, model, maxBoot = 300)
#' result2
#' }
#'
#' @export
sp.anogva <- function(G, model, maxBoot=500, spectra=NULL, eps=0.01, classic=TRUE, bandwidth="Silverman"){

  data.name <- deparse(substitute(G))
  graph <- G

  if(methods::is(graph, "list") && methods::is(graph[[1]], "igraph")) graph <- f.transform(graph)

  g <- length(graph)
  p.hat <- list()
  for(l in 1:g){
    n <- as.character(ncol(graph[[l]]))
    if(methods::is(spectra, "list")){
      p.hat[[l]] <- graph.param.estimator(
        graph[[l]], model, eps=eps, bandwidth=bandwidth, spectra=spectra[[n]], classic=classic)$p
    } else p.hat[[l]] <- graph.param.estimator(
      graph[[l]], model, eps=eps, bandwidth=bandwidth, spectra=spectra, classic=classic)$p
  }
  p.boot <- matrix(0, length(graph), maxBoot)
  for (boot in 1:maxBoot){
    g.boot <- list()
    for (l in 1:g){
      n <- as.character(ncol(graph[[l]]))
      if(model == "ER"){
        g.boot[[l]] <- ER(ncol(graph[[l]]), p.hat[[l]])
      }
      else if(model == "GRG"){
        g.boot[[l]] <- GRG(ncol(graph[[l]]), p.hat[[l]])
      }
      else if(model == "WS"){
        g.boot[[l]] <- WS(ncol(graph[[l]]),p.hat[[l]],2)
      }
      else if(model == "BA"){
        g.boot[[l]] <- BA(ncol(graph[[l]]), p.hat[[l]])
      }
      if(methods::is(spectra, "list")){
        p.boot[l,boot] <- graph.param.estimator(
          g.boot[[l]], model, eps=eps, bandwidth=bandwidth, spectra=spectra[[n]], classic=classic)$p
      } else p.boot[l,boot] <- graph.param.estimator(
        g.boot[[l]], model, eps=eps, bandwidth=bandwidth, spectra=spectra, classic=classic)$p
    }
  }
  var.boot <- array(0, g)
  for(l in 1:g) var.boot[l] <- var(p.boot[l,])
  SSres <- 0
  SStr <- 0
  m <- mean(as.numeric(as.array(p.hat)))
  for(l in 1:g){
    SSres <- SSres + (maxBoot - 1) * var.boot[l]
    SStr <- SStr + (p.hat[[l]] - m) ^ 2
  }
  
  F_ <- (SStr / (g - 1)) / ( SSres / (g * maxBoot - g))
  p <- pf(F_, df1=(g-1), df2=(g * maxBoot - g), lower.tail=FALSE)

  names(F_)  <- "F.value"
  estimate <- unlist(p.hat)
  names(estimate) <- paste("parameter", 1:length(estimate), sep='')
  method <- "Semi-Parametric Analysis Of Graph Variability"
  rval <- list(statistic=F_, p.value=p, method=method, data.name=data.name, estimate=estimate)
  class(rval) <- "htest"
  return(rval)
}

