#' Ghoshdastidar hypothesis testing for large random graphs.
#'
#' Given two lists of graphs generated by the inhomogeneous random graph model,
#' \code{ghoshdastidar.test} tests if they were generated by the same parameters.
#'
#' @param G1 the first list of undirected graphs to be compared. Must be a list
#' of matrices or igraph objects.
#'
#' @param G2 the second list of undirected graphs to be compared. Must be a list
#' of matrices or igraph objects.
#'
#' @param maxBoot integer indicating the number of bootstrap resamples (default
#' is 300).
#'
#' @param two.sample logical. If TRUE the sets contain only one graph each. If
#' FALSE the sets contain more than one graph each (default is FALSE).
#'
#
#' @return A list with class "htest" containing the following components:
#' \item{statistic}{the T-value of the test.}
#' \item{p.value}{the p-value of the test (only returned when the parameter
#' 'two.sample' is FALSE).}
#' \item{method}{a string indicating the used method.}
#' \item{data.name}{a string with the data's name(s).}
#'
#' @references
#' Ghoshdastidar, Debarghya, et al. "Two-sample tests for large random graphs
#' using network statistics". arXiv preprint arXiv:1705.06168 (2017).
#'
#' Ghoshdastidar, Debarghya, et al. "Two-sample hypothesis testing for
#' inhomogeneous random graphs". arXiv preprint, arXiv:1707.00833 (2017).
#'
#' @examples
#' \dontrun{
#' set.seed(42)
#'
#' ## test for sets with more than one graph each under H0
#' G1 <- G2 <- list()
#' for(i in 1:10){
#'   G1[[i]] <- as.matrix(igraph::get.adjacency(igraph::sample_gnp(50,0.6)))
#'   G2[[i]] <- as.matrix(igraph::get.adjacency(igraph::sample_gnp(50,0.6)))
#' }
#' D1 <- ghoshdastidar.test(G1, G2)
#' D1
#'
#' ## test for sets with more than one graph each under H1
#' G1 <- G2 <- list()
#' for(i in 1:10){
#'   G1[[i]] <- as.matrix(igraph::get.adjacency(igraph::sample_gnp(50,0.6)))
#'   G2[[i]] <- as.matrix(igraph::get.adjacency(igraph::sample_gnp(50,0.7)))
#' }
#' D2 <- ghoshdastidar.test(G1, G2)
#' D2
#'
#' ## test for sets with only one graph each under H0
#' G1 <- G2 <- list()
#' G1[[1]] <- igraph::sample_gnp(300, 0.6)
#' G2[[1]] <- igraph::sample_gnp(300, 0.6)
#' D3 <- ghoshdastidar.test(G1, G2, two.sample= TRUE)
#' D3
#'
#' ## test for sets with only one graph each under H1
#' G1 <- G2 <- list()
#' G1[[1]] <- igraph::sample_gnp(300, 0.6)
#' G2[[1]] <- igraph::sample_gnp(300, 0.7)
#' D4 <- ghoshdastidar.test(G1, G2, two.sample= TRUE)
#' D4
#' }
#'
#' @export
ghoshdastidar.test <- function(G1, G2, maxBoot = 300, two.sample = FALSE)
{

  data.name <- paste(deparse(substitute(G1)),"and",deparse(substitute(G2)))

  if(methods::is(G1, "list") && methods::is(G1[[1]], "igraph")){
    G1 <- g.transform(G1)
  }
  if(methods::is(G2, "list") && methods::is(G2[[1]], "igraph")){
    G2 <- g.transform(G2)
    }
  if(methods::is(G1, "igraph") && methods::is(G2, "igraph")){
    G1 <- g.transform(G1)
    G2 <- g.transform(G2)
  }


  if(!methods::is(G1, "list") || !methods::is(G1[[1]], "matrix")){
    stop("G1 must be a list of matrices or igraph objects.")
  } 
  if(!methods::is(G2, "list") || !methods::is(G2[[1]], "matrix")){
    stop("G2 must be a list of matrices or igraph objects.")
  }
  D <- g.test(G1, G2)

  statistic <- D
  names(statistic) <- "T"
  method <- "Ghoshdastidar hypothesis testing for large random graphs"

  if(!two.sample){
    test_distribution <- g.sampling.distribution(G1,G2,maxBoot)
    p_val <- mean(test_distribution >= D)
    rval <- list(statistic=statistic, p.value=p_val, method=method, data.name=data.name)
  }
  else{
    rval <- list(statistic=statistic, method=method, data.name=data.name)
  }
  class(rval) <- "htest"
  return(rval)
}

g.test <- function(x, y){
  m <- min(length(x), length(y))
  x <- lapply(x, function(s){
    s2 <- s
    s2[lower.tri(s2)]<-0
    eval.parent(substitute(s<-s2))
  })
  y <- lapply(y, function(s){
    s2 <- s
    s2[lower.tri(s2)]<-0
    eval.parent(substitute(s<-s2))
  })

  n <- dim(x[[1]])[1]
  Sm1 <- matrix(0, 1, m)
  Sp1 <- matrix(0, 1, m)
  Sm2 <- matrix(0, 1, m)
  Sp2 <- matrix(0, 1, m)

  for(i in 1:m){
    Sm1[i] <- sum(x[[i]] * (x[[i]] %*% x[[i]])) / (6 * choose(n, 3))
    Sp1[i] <- Sm1[i] * log(n) / choose(n, 3)

    Sm2[i] <- sum(y[[i]] * (y[[i]] %*% y[[i]])) / (6 * choose(n, 3))
    Sp2[i] <- Sm2[i] * log(n) / choose(n, 3)
  }

  num <- abs(sum(Sm1 - Sm2));
  den <- 2 * (sqrt(sum(Sp1)) + sqrt(sum(Sp2)))

  if(den == 0) den <- 1
  stat <- abs(num / den)
  return(stat)
}


g.sampling.distribution <- function(x, y, maxBoot = 300)
{
  m1 <- length(x)
  m2 <- length(y)
  test_distribution = c()
  for (i_per in 1:maxBoot){
    xe <- sample(append(x,y), m1, replace = TRUE)
    ye <- sample(append(x,y), m2, replace = TRUE)
    test_distribution[i_per] <- g.test(xe, ye)
  }
  return(sort(test_distribution))
}


g.transform <- function(g)
{
  if(methods::is(g, "igraph")){
    return(list(as.matrix(igraph::get.adjacency(g))))
  }
  else{
    result <- lapply(g, function(x){
      return(as.matrix(igraph::get.adjacency(x)))
    })
  }
}

