#' Graph parameter estimator
#'
#' \code{graph.param.estimator} estimates the parameter that best approximates
#' the model to the observed graph according to the Graph Information Criterion
#' (GIC).
#'
#' @param G the undirected graph (igraph type) or its adjacency matrix. The
#' adjacency matrix of an unweighted graph contains only 0s and 1s, while the
#' weighted graph may have nonnegative real values that correspond to the
#' weights of the edges.
#'
#' @param model either a string or a function:
#'
#' A string that indicates one of the following models: "ER" (Erdos-Renyi random
#' graph), "GRG" (geometric random graph), "KR" (k regular random graph), "WS"
#' (Watts-Strogatz model), and "BA" (Barabasi-Albert model).
#'
#' A function that returns a graph (represented by its adjacency matrix)
#' generated by a graph model. It must contain two arguments: the first one
#' corresponds to the graph size and the second to the parameter of the model.
#'
#' @param spectra optional parameter containing the precomputed spectrum of the
#' model. It is a three-dimensional array in which the first dimension
#' corresponds to all parameters that will be explored in the grid, the second
#' dimension has the same size of the given graph, and the third one corresponds
#' to graphs randomly generated by the model. Thus, the position (i,j,k)
#' contains the j-th eigenvalue of the k-th graph generated with the i-th
#' parameter. The attribute 'rownames' of the array corresponds to the
#' parameters converted to string. If spectra is NULL (default), then 'model' is
#' used to generate random graphs and their spectra are computed automatically.
#'
#' @param parameters numeric vector containing the values that that will be
#' considered for the parameter estimation. The 'graph.param.estimator' will
#' return the element of 'parameter' that minimizes the Kullback-Leiber divergence
#' or L1 norm.
#' If the user does not provide the argument 'parameters', and 'model' is an
#' array, then the values considered for the parameter estimation are the
#' rownames converted to a numeric vector. If 'model' is a string, then
#' default values are used for the predefined models ("ER", "GRG", "KR", "WS",
#' and "BA"). The default 'parameter' argument corresponds to a sequence from
#'
#' 0 to 1 with step 'eps' for the "ER" model (Erdos-Renyi random graph), in
#' which the parameter corresponds to the probability to connect a pair of
#' vertices;
#'
#' 0 to sqrt(2) with step 'eps' for the "GRG" model (geometric random graph), in
#' which the parameter corresponds to the radius used to construct the geometric
#' graph in a unit square;
#'
#' 0 to 'n' with step 'n*eps' for the "KR" model (k regular random graph), in
#' which the parameter of the model corresponds to the degree 'k' of a regular
#' graph;
#'
#' 0 to 1 with step 'eps' for the "WS" model (Watts-Strogatz model), in which
#' the parameter corresponds to the probability to reconnect a vertex;
#'
#' and 0 to 3 with step 'eps' for the "BA" model (Barabasi-Albert model), in
#' which the parameter corresponds to the scaling exponent.
#'
#' The default 'parameter' is also used when \code{classic} = FALSE.
#'
#' @param eps precision of the grid (default is 0.01) when 'classic' is TRUE.
#'
#' @param bandwidth string showing which criterion is used to choose the
#' bandwidth during the spectral density estimation. Choose between the
#' following criteria: "Silverman" (default), "Sturges", "bcv", "ucv" and "SJ".
#' "bcv" is an abbreviation of biased cross-validation, while "ucv" means
#' unbiased cross-validation. "SJ"  implements the methods of Sheather & Jones
#' (1991) to select the bandwidth using pilot estimation of derivatives.
#'
#' @param eigenvalues optional parameter. It contains the eigenvalues of matrix
#' G. Then, it can be used when the eigenvalues of G were previously computed.
#' If no value is passed, then the eigenvalues of G will be computed by
#' 'graph.param.estimator'.
#'
#' @param classic logical. If FALSE parameter is estimated using the graph
#' parameter estimator, where this option works better for large graphs with
#' 1000 or more nodes. If TRUE (default) parameter is estimated using grid
#' search.
#'
#' @param npoints Number of points to discretize the interval of the largest and smallest eigenvalue of the
#' graph's adjacency matrix eigenvalues. Only used when \code{classic} = FALSE.
#'
#' @param numCores Number of cores to use for parallelization. Only used when \code{classic} = FALSE.
#'
#' @return A list with class "statGraph" containing the following components:
#' \item{method}{a string indicating the used method.}
#' \item{info}{a string showing details about the method.}
#' \item{data.name}{a string with the data's name(s).}
#' \item{param}{the parameter estimate. For the "ER", "GRG", "KR", "WS", and "BA"
#' models, the parameter corresponds to the probability to connect a pair of
#' vertices, the radius used to construct the geometric graph in a unit square,
#' the degree k of a regular graph, the probability to reconnect a vertex, and
#' the scaling exponent, respectively.}
#' \item{KLD}{the Kullback-Leibler divergence between the observed graph and
#' the graph model with the estimated parameter. Only returned if
#' \code{classic} = TRUE.}
#'
#' @keywords parameter_estimation
#'
#' @references
#' Takahashi, D. Y., Sato, J. R., Ferreira, C. E. and Fujita A. (2012)
#' Discriminating Different Classes of Biological Networks by Analyzing the
#' Graph Spectra  Distribution. _PLoS ONE_, *7*, e49949.
#' doi:10.1371/journal.pone.0049949.
#'
#' Silverman, B. W. (1986) _Density Estimation_.  London: Chapman and Hall.
#'
#' Sturges, H. A. The Choice of a Class Interval. _J. Am. Statist. Assoc._,
#' *21*, 65-66.
#'
#' Sheather, S. J. and Jones, M. C. (1991). A reliable data-based bandwidth
#' selection method for kernel density estimation.
#' _Journal of the Royal Statistical Society series B_, 53, 683-690.
#' http://www.jstor.org/stable/2345597.
#'
#' @examples
#' set.seed(1)
#' G <- igraph::sample_gnp(n=50, p=0.5)
#'
#' # Using a string to indicate the graph model
#' result1 <- graph.param.estimator(G, "ER", eps=0.25)
#' result1
#'
#' \dontrun{
#' # Using a function to describe the graph model
#' # Erdos-Renyi graph
#' set.seed(1)
#' model <- function(n, p){
#'   return(igraph::sample_gnp(n, p))
#' }
#' result2 <- graph.param.estimator(G, model,  seq(0.2, 0.8, 0.1))
#' result2
#'
#'
#' ### Example giving only the name of the model to use
#' G <- igraph::sample_smallworld(dim = 1, size = 15, nei = 2, p = 0.2)
#'
#' # Obtain the parameter of the WS model
#' result3 <- graph.param.estimator(G, "WS", eps = 1e-1, npoints = 10,
#'                                  numCores = 1)
#' result3
#' }
#'
#' @export
graph.param.estimator <- function(G, model, parameters = NULL, npoints = 100, ngraphs = 1, numCores = 1, bandwidth="Silverman", search_mode = "ternary_search", distance = "L1", directed=FALSE, from = NULL, to = NULL, use_degree_based_estimation = FALSE, use_grid_optimization = FALSE, grid_optimization_parameters = list(), log = FALSE){

    A <- get.adjacency.matrix(G)
    n <- ncol(A)

    # Verification that input is Valid:

    if(methods::is(model, "function") && is.null(parameters)){
        stop("It is necessary to enter the parameters that will be evaluated.")
    }
    if(!directed && !isSymmetric(G)){
        directed <- TRUE
        warning("Graph is non-symmetric. Switching to directed.")
    }

    if(directed){
        if(!methods::is(model, "function")){
            stop("For directed graphs, only functions are accepted as Models.")
        }
        if(search_mode == "grid_search"){
            search <- grid_search
        }
        else if(search_mode == "ternary_search"){
            search <- ternary_search
        }
        else {
            stop("Unknown search mode. Current valid options are 'grid_search' and 'ternary_search'.")
        }

        if(use_degree_based_estimation) {
            stop("Usage of degree-based estimation is not yet implemented for directed graphs.")
        }
        else {
            #TODO: Should graphSpec be calculated with the same from, to of modelSpec??
            graphSpec <- spectralDensity(G,from = from, to = to, bandwidth = bandwidth, npoints = npoints, directed=TRUE)
            criteria <- memoise(function(x)
            {
		if(use_grid_optimization) {
			x = convert_to_grid(x, grid_optimization_parameters$min, grid_optimization_parameters$max, grid_optimization_parameters$spacing)
		}
                modelSpec <- modelSpectralDensity(model, n, x, from = from, to = to, bandwidth = bandwidth, ngraphs = ngraphs, npoints = npoints, directed=TRUE)
                dist <- Dist(graphSpec, modelSpec, distance = distance)
                return(dist)
            })
        }
        result <- search(criteria, parameters, log = log)
        out = list(param = result$arg, KLD= result$val)

        method    <- "Graph parameter estimator"
        info     <- "Estimating the parameter that best approximates the model to the observed graph"
        data.name <- deparse(substitute(G))
        output     <- list(method=method, info=info, data.name=data.name, param=out$param, KLD=out$KLD)
        attr(output, "class") <- "statGraph"
        return(output)
    }
    else{
        # Dealing with known models.
        # TODO: Fix this. eigenvalues is currently NULL
        if(methods::is(model, "character") && model == "ER"){
            out <- parameter.estimator.erdos.renyi(A, bandwidth, eigenvalues)
        }
        else if(methods::is(model, "character") && model == "KR"){
            out <- parameter.estimator.k.regular(A, bandwidth, eigenvalues)
        }
        else if(methods::is(model, "character") && model == "KR"){
            out <- parameter.estimator.k.regular(A, bandwidth, eigenvalues)
        }
        # Dealing with unknown models
        else{
            if(search_mode == "grid_search"){
                search <- grid_search
            }
            else if(search_mode == "ternary_search"){
                search <- ternary_search
            }
            else {
                stop("Unknown search mode. Current valid options are 'grid_search' and 'ternary_search'.")
            }

            if(use_degree_based_estimation) {
                # TODO: How to reconcile the usage of get.spectral.density with the rest of the codebase?
                # The following criteria function should work as intended for directed matrices.
                # Can rARPACK be used to compute complex eigenvalues?
                # If not, should the choice of using get.spectral.density vs 

                graphSpec <- get.spectral.density(G,from = from, to = to, bandwidth = bandwidth, npoints = npoints, directed=FALSE)
                criteria <- function(x)
                {
                    sampleGraph <- do.call(model, as.list(c(n, x)))
                    modelSpec <- get.spectral.density(graph, from=from, to=to, npoints=npoints, numCores=numCores)

                    dist <- Dist(graphSpec, modelSpec, distance = distance)
                    return(dist)
                }

            }
            else {
                graphSpec <- spectralDensity(G,from = from, to = to, bandwidth = bandwidth, npoints = npoints, directed=FALSE)
                criteria <- function(x)
                {
                    modelSpec <- modelSpectralDensity(model, n, x, from = from, to = to, bandwidth = bandwidth, ngraphs = ngraphs, npoints = npoints, directed=FALSE)
                    dist <- Dist(graphSpec, modelSpec, distance = distance)
                    return(dist)
                }
            }


            result <- search(criteria, parameters)

            out = list(param = result$arg, KLD= result$val)
        }
        method    <- "Graph parameter estimator"
        info     <- "Estimating the parameter that best approximates the model to the observed graph"
        data.name <- deparse(substitute(G))
        output     <- list(method=method, info=info, data.name=data.name, param=out$param, KLD=out$KLD)
        attr(output, "class") <- "statGraph"
        return(output)
    }
}

#   Performs a ternary search attempting to minimize a criteria.
#   Accepts the following input:
#       criteria: A function criteria(x1, x2, ..., xn) that returns a real number
#       parameters: A list containing three elements: parameters$min, parameters$max and parameters$eps.
#           parameters$min must be a vector (min_1, min_2, ..., min_N)
#           parameters$max must be a vector (max_1, max_2, ..., max_N)
#           parameters$eps must be a vector (eps_)1, eps_2, ..., eps_N)
#   The method will perform a ternary search. The argument xi will be searched in the interval (min_i, max_i) with an epsilon of eps_i

ternary_search <- function(criteria, parameters, log = FALSE)
{
    if(is.null(parameters$min) || is.null(parameters$max) || is.null(parameters$eps)){
        stop("Wrong input for Ternary search. Parameters should be a list containing elements $min, $max and $eps, of type vector. The ternary search will then search parameter i in the interval [min[i], max[i]] using an epsilon of eps[i]. Read the documentation!")
    }

    if(log){
        cat("Starting ternary search\n")
    }

    min <- parameters$min
    max <- parameters$max
    eps <- parameters$eps

    if(length(min) == 1)
    {
        lo <- min[1]
        hi <- max[1]
        leps <- eps[1]
	
        val1 <- 0
        val2 <- 0
        while(abs(hi - lo) > leps && lo < hi)
        {
            mid1 <- (2*lo + hi) / 3
            mid2 <- (2*hi + lo) / 3
	    if(log){
	        cat("Parameter: ", length(min), "  -  Hi = ", hi, " Lo = ", lo, "\n")
	    }

            val1 <- criteria(c(mid1))
            val2 <- criteria(c(mid2))

            if(val1 < val2) {
                hi <- mid2
            }
            else {
                lo <- mid1
            }
        }

        minarg <- (hi + lo) / 2
        minval <- (val1 + val2) / 2 
        out <- list("arg" = minarg, "val" = minval)
        return(out)
    }
    else
    {
        lo <- min[1]
        hi <- max[1]
        leps <- eps[1]
	

        newmin <- min[-1]
        newmax <- max[-1]
        neweps <- eps[-1]

        val1 <- 0
        val2 <- 0

        outarg <- c()

        while(abs(lo - hi) > leps && lo < hi)
        {
            mid1 <- (2*lo + hi) / 3
            mid2 <- (2*hi + lo) / 3
	    

            crit1 <- function(x)
            {
                out <- criteria(c(mid1, x))
                return(out)
            }
            crit2 <- function(x)
            {
                out <- criteria(c(mid2, x))
                return(out)
            }

            newparameters = list(min=newmin, max=newmax, eps=neweps)

            localmin1 <- ternary_search(crit1, newparameters, log = FALSE)
            localmin2 <- ternary_search(crit2, newparameters, log = FALSE)

            val1 <- localmin1$val
            val2 <- localmin2$val

            if(val1 < val2){
                hi <- mid2
                outarg <- c(localmin1$arg)
            }
            else{
                lo <- mid1
                outarg <- c(localmin2$arg)
            }

            if(log){
                log_arg <- (hi + lo) / 2
                log_args <- c(log_arg, outarg)
                cat("Eps: ", abs(lo - hi), "\t Arguments: ", log_args, " (lo, hi) = (", lo, " , ", hi, ")\n") 
	        }
        }

        minval <- (val1 + val2) / 2
        minarg <- (hi + lo) / 2
        outarg <- c(minarg, outarg)

        out <- list("arg" = outarg, "val" = minval)
        return(out)

    }
}


#   Performs a grid search attempting to minimize a criteria.
#   Accepts the following input:
#       criteria: A function criteria(x1, x2, ..., xn) that returns a real number
#       parameters: A list of parameters adjusted to the following conventions:
#           parameters[[i]] correspond to a vector of the possible values for argument xi
#
#   The method will perform a grid search in the space parameters[[1]] x parameters[[2]] x ... x parameters[[N]]
# searching for the values that minimizes the function criteria

grid_search <- function(criteria, parameters, log = FALSE)
{
    # If input is vector instead of a list, fix it.
    if(is.atomic(parameters)){
        parameters = list(parameters)
    }

    if(length(parameters) == 1)
    {
        pslice <- parameters[[1]]

        if(length(pslice) == 0){
            stop("Wrong input for Grid search. Received an empty parameter list. Parameters should be a list such that list[n]] contains a vector of possible parameters for the n-th argument of the criteria function.")
        }

        minarg <- pslice[1]
        minval <- Inf

        for(p in pslice)
        {
            val <- criteria(c(p))

            if(val < minval){
                minarg <- p
                minval <- val
            }
        }

        out <- list("arg" = minarg, "val" = minval)
        return(out)
    }
    else
    {
        newparameters <- parameters[-1]
        pslice <- parameters[[1]]

        if(length(pslice) == 0){
            stop("Wrong input for Grid search. Received an empty parameter list. Parameters should be a list such that list[n]] contains a vector of possible parameters for the n-th argument of the criteria function.")
        }

        minarg <- pslice[1]
        minval <- Inf

        # This isn't needed, I think. TODO: Remove?
        outarg <- c()

        for(p in pslice)
        {
            newcriteria <- function(x)
            {
                out <- criteria(c(p, x))
                return(out)
            }

            localmin <- grid_search(newcriteria, newparameters)
            val <- localmin$val

            if(val < minval)
            {
                minarg <- p
                minval <- val
                outarg <- c(p, localmin$arg)
            }
        }

        out <- list("arg" = outarg, "val" = minval)
        return(out)
    }
}

parameter.estimator.erdos.renyi <- function(A, bandwidth, eigenvalues){
    n <- ncol(A)
    p = sum(A)/(n*(n-1))
    kl <- GIC(A, "ER", p, bandwidth, eigenvalues=eigenvalues)$value
    out <- list("param" = p, "KLD" = kl)
    return(out)
}


parameter.estimator.k.regular <- function(A, bandwidth, eigenvalues){
    n <- ncol(A)
    p = sum(A)/(n)
    kl <- GIC(A, "KR", p, bandwidth, eigenvalues=eigenvalues)$value
    out <- list("param" = p, "KLD" = kl)
    return(out)
}
convert_to_grid <- function(x, min, max, eps) {
  steps_from_min <- round((x - min) / eps)
  closest_point <- min + steps_from_min * eps
  closest_point <- pmax(min, pmin(max, closest_point))
  return(closest_point)
}
